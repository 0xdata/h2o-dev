# This file is auto-generated by h2o-3/h2o-bindings/bin/gen_R.py
# Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details) 
#'
# -------------------------- Target Encoding -------------------------- #
#' 
#' Creates a target encoding frame based on a group-by column and a target column (numeric or binary).
#' 
#' Calculates the mean of the target column per group removing the value of the existing row.
#' This can help predictive performance of high cardinality categorical columns in supervised learning problems.
#' 
#' @param group_column An H2OFrame object with a single categorical column.
#' @param y An H2OFrame object with a single numeric column.
#' @param domain (Optional) Vector with response factor for classification.
#' @param noise_level (Optional) The amount of random noise added to the target encoding.  This helps prevent overfitting. Defaults to 0.01 * range of y.
#' @param seed (Optional) A random seed used to generate draws from the uniform distribution for random noise. Defaults to -1.
#' @return Returns an H2OFrame object containing the leave one out target encoding.
#' @examples
#' \donttest{
#' library(h2o)
#' h2o.init()
#' 
#' # Run Target Encoding on bank-additional-full data with numeric `y`
#' data.hex = h2o.importFile(
#' path = "https://s3.amazonaws.com/h2o-public-test-data/smalldata/demos/bank-additional-full.csv",
#' destination_frame = "data.hex")
#' h2o.target_encoding(data.hex$job, data.hex$age)
#' 
#' # Run Target Encoding on bank-additional-full data with binary `y`
#' h2o.target_encoding(data.hex$job, data.hex$y)
#' }
#' @export

h2o.target_encoding <- function(group_column, y, domain = NULL, noise_level = NULL, seed = -1){
  
  if (missing(group_column)) 
    stop("argument 'group_column' is missing, with no default")
  if (missing(y)) 
    stop("argument 'y' is missing, with no default")
  
  if (!is.h2o(group_column)) 
    stop("argument `group_column` must be a valid H2OFrame")
  if (!is.h2o(y)) 
    stop("argument `y` ust be a valid H2OFrame")
  
  if(ncol(group_column) > 1)
    stop("`group_column` must have one column")
  if(ncol(y) > 1)
    stop("`y` must have one column")
  
  if (is.numeric(group_column) || length(group_column) == 0L) 
    stop("`group_column` must be a numeric vector")
  
  if(!is.null(noise_level))
    if(!is.numeric(noise_level) || length(noise_level) > 1L)
      stop("`noise_level` must be a numeric vector of length 1")
    else if (noise_level < 0)
      stop("`noise_level` must be non-negative")
  
  y_levels <- h2o.levels(y)
  if (is.factor(y)) {
    if (length(y_levels) == 2)
      if(!is.null(domain))
        y <- h2o.ifelse(is.na(y), NA, h2o.ifelse(y == domain[[1]], 0, 1))
      else
        y <- h2o.ifelse(is.na(y), NA, h2o.ifelse(y == y_levels[[1]], 0, 1))
    else stop(paste0("`y` must be a numeric or binary vector - has ", length(y_levels), " levels"))
  }
  
  # Remove records where y is NA
  encoding_data <- h2o.cbind(group_column, y)
  colnames(encoding_data) <- c("group", "y")
  encoding_data <- encoding_data[!is.na(encoding_data$y), ]
  
  # Calculate sum of y and number of rows per level of group_column
  group_agg <- h2o.group_by(encoding_data, "group", sum("y"), nrow("y"))
  colnames(group_agg) <- c("group", "numerator", "denominator")
  
  # Merge to Encoding Data
  encoding_data <- h2o.merge(encoding_data, group_agg, by = "group", all.x = TRUE, all.y = FALSE)
  
  # Calculate Mean Target per Group - removing value of existing row
  target_encoding <- h2o.ifelse(is.na(encoding_data$y), 
                                encoding_data$numerator/encoding_data$denominator,
                                (encoding_data$numerator - encoding_data$y)/(encoding_data$denominator - 1)
                                )
  
  # Add Random Noise
  
  if(is.null(noise_level)){
    # If `noise_level` is NULL, value chosen based on `y` distribution
    noise_level <- (max(encoding_data$y) - min(encoding_data$y))*0.01
  }
  
  if(noise_level > 0){
    # Generate random floats sampled from a uniform distribution  
    random_noise <- h2o.runif(target_encoding, seed = seed)
    # Scale within noise_level
    random_noise <- random_noise * 2 * noise_level - noise_level
    # Add noise to target_encoding
    target_encoding <- target_encoding + random_noise
  }
  
  return(target_encoding)
}
