#!/usr/bin/env python
# -*- encoding: utf-8 -*-
#
# This file is auto-generated by h2o-3/h2o-bindings/bin/gen_python.py
# Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details)
#
from __future__ import absolute_import, division, print_function, unicode_literals

from h2o.estimators.estimator_base import H2OEstimator
from h2o.exceptions import H2OValueError
from h2o.frame import H2OFrame
from h2o.utils.typechecks import assert_is_type, Enum, numeric

from h2o.utils.shared_utils import stringify_dict_as_map


class H2OTeaEstimator(H2OEstimator):
    """
    Tea

    Builds a RuleFit on a parsed dataset, for regression or 
    classification. 
    """

    algo = "tea"
    param_names = {"model_id", "seed", "training_frame", "validation_frame", "autobin_sampling_n_records",
                   "autobin_mode_density", "autobin_quantile_density", "autobin_quantile_error",
                   "autobin_sketch_confidence", "autobin_eps_of_total_count", "autobin_max_categoricals",
                   "autobin_label_null_string", "autobin_label_bin_variable", "autobin_label_bin_value",
                   "autobin_label_bin_density", "autobin_label_bin_scale_type", "autobin_label_bin_data_type",
                   "autobin_label_bin_sv", "autobin_label_categorical_value", "autobin_label_continuous_value",
                   "density_support", "metric_regex", "label_record_id", "label_run", "label_passthrough",
                   "label_sampled_score", "label_score", "label_bin", "label_bin_prob", "label_variable", "label_value",
                   "label_min_score", "label_max_score", "label_range", "label_upside", "label_downside",
                   "label_expected_upside", "label_expected_downside", "label_upside_prob", "label_downside_prob",
                   "label_normalized_upside", "label_normalized_downside", "label_rank", "model_key", "score_threshold",
                   "score_label", "model_scoring_function_result_id", "record_id", "explain_field_regex",
                   "ranking_metric", "special_values"}

    def __init__(self, special_vals=None, **kwargs):
        super(H2OTeaEstimator, self).__init__()
        self._parms = {}
        self.special_vals = None if special_vals is None else dict(special_vals)
        self._parms['special_values'] =  None if self.special_vals is None else stringify_dict_as_map(self.special_vals) # unique to grid search
        for pname, pvalue in kwargs.items():
            if pname == 'model_id':
                self._id = pvalue
                self._parms["model_id"] = pvalue
            elif pname in self.param_names:
                # Using setattr(...) will invoke type-checking of the arguments
                setattr(self, pname, pvalue)
            else:
                raise H2OValueError("Unknown parameter %s = %r" % (pname, pvalue))

    @property
    def seed(self):
        """
        Seed for pseudo random number generator (if applicable).

        Type: ``int``  (default: ``-1``).
        """
        return self._parms.get("seed")

    @seed.setter
    def seed(self, seed):
        assert_is_type(seed, None, int)
        self._parms["seed"] = seed


    @property
    def training_frame(self):
        """
        Id of the training data frame.

        Type: ``H2OFrame``.
        """
        return self._parms.get("training_frame")

    @training_frame.setter
    def training_frame(self, training_frame):
        self._parms["training_frame"] = H2OFrame._validate(training_frame, 'training_frame')


    @property
    def validation_frame(self):
        """
        Id of the validation data frame.

        Type: ``H2OFrame``.
        """
        return self._parms.get("validation_frame")

    @validation_frame.setter
    def validation_frame(self, validation_frame):
        self._parms["validation_frame"] = H2OFrame._validate(validation_frame, 'validation_frame')


    @property
    def autobin_sampling_n_records(self):
        """
        autobin_sampling_n_records configuration value. Defaults to 10000.

        Type: ``int``  (default: ``10000``).
        """
        return self._parms.get("autobin_sampling_n_records")

    @autobin_sampling_n_records.setter
    def autobin_sampling_n_records(self, autobin_sampling_n_records):
        assert_is_type(autobin_sampling_n_records, None, int)
        self._parms["autobin_sampling_n_records"] = autobin_sampling_n_records


    @property
    def autobin_mode_density(self):
        """
        autobin_mode_density configuration value. Defaults to 0.05.

        Type: ``float``  (default: ``0.05``).
        """
        return self._parms.get("autobin_mode_density")

    @autobin_mode_density.setter
    def autobin_mode_density(self, autobin_mode_density):
        assert_is_type(autobin_mode_density, None, numeric)
        self._parms["autobin_mode_density"] = autobin_mode_density


    @property
    def autobin_quantile_density(self):
        """
        autobin_quantile_density configuration value. Defaults to 0.10.

        Type: ``float``  (default: ``0.1``).
        """
        return self._parms.get("autobin_quantile_density")

    @autobin_quantile_density.setter
    def autobin_quantile_density(self, autobin_quantile_density):
        assert_is_type(autobin_quantile_density, None, numeric)
        self._parms["autobin_quantile_density"] = autobin_quantile_density


    @property
    def autobin_quantile_error(self):
        """
        autobin_quantile_error configuration value. Defaults to 0.03.

        Type: ``float``  (default: ``0.03``).
        """
        return self._parms.get("autobin_quantile_error")

    @autobin_quantile_error.setter
    def autobin_quantile_error(self, autobin_quantile_error):
        assert_is_type(autobin_quantile_error, None, numeric)
        self._parms["autobin_quantile_error"] = autobin_quantile_error


    @property
    def autobin_sketch_confidence(self):
        """
        autobin_sketch_confidence configuration value. Defaults to 0.995.

        Type: ``float``  (default: ``0.995``).
        """
        return self._parms.get("autobin_sketch_confidence")

    @autobin_sketch_confidence.setter
    def autobin_sketch_confidence(self, autobin_sketch_confidence):
        assert_is_type(autobin_sketch_confidence, None, numeric)
        self._parms["autobin_sketch_confidence"] = autobin_sketch_confidence


    @property
    def autobin_eps_of_total_count(self):
        """
        autobin_eps_of_total_count configuration value. Defaults to 1e-4.

        Type: ``float``  (default: ``0.0001``).
        """
        return self._parms.get("autobin_eps_of_total_count")

    @autobin_eps_of_total_count.setter
    def autobin_eps_of_total_count(self, autobin_eps_of_total_count):
        assert_is_type(autobin_eps_of_total_count, None, numeric)
        self._parms["autobin_eps_of_total_count"] = autobin_eps_of_total_count


    @property
    def autobin_max_categoricals(self):
        """
        autobin_max_categoricals configuration value. Defaults to 1000.

        Type: ``int``  (default: ``1000``).
        """
        return self._parms.get("autobin_max_categoricals")

    @autobin_max_categoricals.setter
    def autobin_max_categoricals(self, autobin_max_categoricals):
        assert_is_type(autobin_max_categoricals, None, int)
        self._parms["autobin_max_categoricals"] = autobin_max_categoricals


    @property
    def autobin_label_null_string(self):
        """
        autobin_label_null_string configuration value. Defaults to "____null_____".

        Type: ``str``  (default: ``"____null_____"``).
        """
        return self._parms.get("autobin_label_null_string")

    @autobin_label_null_string.setter
    def autobin_label_null_string(self, autobin_label_null_string):
        assert_is_type(autobin_label_null_string, None, str)
        self._parms["autobin_label_null_string"] = autobin_label_null_string


    @property
    def autobin_label_bin_variable(self):
        """
        autobin_label_bin_variable configuration value. Defaults to "binVariable".

        Type: ``str``  (default: ``"binVariable"``).
        """
        return self._parms.get("autobin_label_bin_variable")

    @autobin_label_bin_variable.setter
    def autobin_label_bin_variable(self, autobin_label_bin_variable):
        assert_is_type(autobin_label_bin_variable, None, str)
        self._parms["autobin_label_bin_variable"] = autobin_label_bin_variable


    @property
    def autobin_label_bin_value(self):
        """
        autobin_label_bin_value configuration value. Defaults to "binValue".

        Type: ``str``  (default: ``"binValue"``).
        """
        return self._parms.get("autobin_label_bin_value")

    @autobin_label_bin_value.setter
    def autobin_label_bin_value(self, autobin_label_bin_value):
        assert_is_type(autobin_label_bin_value, None, str)
        self._parms["autobin_label_bin_value"] = autobin_label_bin_value


    @property
    def autobin_label_bin_density(self):
        """
        autobin_label_bin_density configuration value. Defaults to "density".

        Type: ``str``  (default: ``"density"``).
        """
        return self._parms.get("autobin_label_bin_density")

    @autobin_label_bin_density.setter
    def autobin_label_bin_density(self, autobin_label_bin_density):
        assert_is_type(autobin_label_bin_density, None, str)
        self._parms["autobin_label_bin_density"] = autobin_label_bin_density


    @property
    def autobin_label_bin_scale_type(self):
        """
        autobin_label_bin_scale_type configuration value. Defaults to "scaleType".

        Type: ``str``  (default: ``"scaleType"``).
        """
        return self._parms.get("autobin_label_bin_scale_type")

    @autobin_label_bin_scale_type.setter
    def autobin_label_bin_scale_type(self, autobin_label_bin_scale_type):
        assert_is_type(autobin_label_bin_scale_type, None, str)
        self._parms["autobin_label_bin_scale_type"] = autobin_label_bin_scale_type


    @property
    def autobin_label_bin_data_type(self):
        """
        autobin_label_bin_data_type configuration value. Defaults to "dataType".

        Type: ``str``  (default: ``"dataType"``).
        """
        return self._parms.get("autobin_label_bin_data_type")

    @autobin_label_bin_data_type.setter
    def autobin_label_bin_data_type(self, autobin_label_bin_data_type):
        assert_is_type(autobin_label_bin_data_type, None, str)
        self._parms["autobin_label_bin_data_type"] = autobin_label_bin_data_type


    @property
    def autobin_label_bin_sv(self):
        """
        autobin_label_bin_sv configuration value. Defaults to "sv".

        Type: ``str``  (default: ``"sv"``).
        """
        return self._parms.get("autobin_label_bin_sv")

    @autobin_label_bin_sv.setter
    def autobin_label_bin_sv(self, autobin_label_bin_sv):
        assert_is_type(autobin_label_bin_sv, None, str)
        self._parms["autobin_label_bin_sv"] = autobin_label_bin_sv


    @property
    def autobin_label_categorical_value(self):
        """
        autobin_label_categorical_value configuration value. Defaults to "categorical".

        Type: ``str``  (default: ``"categorical"``).
        """
        return self._parms.get("autobin_label_categorical_value")

    @autobin_label_categorical_value.setter
    def autobin_label_categorical_value(self, autobin_label_categorical_value):
        assert_is_type(autobin_label_categorical_value, None, str)
        self._parms["autobin_label_categorical_value"] = autobin_label_categorical_value


    @property
    def autobin_label_continuous_value(self):
        """
        autobin_label_continuous_value configuration value. Defaults to "continuous".

        Type: ``str``  (default: ``"continuous"``).
        """
        return self._parms.get("autobin_label_continuous_value")

    @autobin_label_continuous_value.setter
    def autobin_label_continuous_value(self, autobin_label_continuous_value):
        assert_is_type(autobin_label_continuous_value, None, str)
        self._parms["autobin_label_continuous_value"] = autobin_label_continuous_value


    @property
    def density_support(self):
        """
        density_support configuration value. Defaults to 1e-4.

        Type: ``float``  (default: ``0.0001``).
        """
        return self._parms.get("density_support")

    @density_support.setter
    def density_support(self, density_support):
        assert_is_type(density_support, None, numeric)
        self._parms["density_support"] = density_support


    @property
    def metric_regex(self):
        """
        metric_regex configuration value. Defaults to "actualScore|minScore|upside|value".

        Type: ``str``  (default: ``"actualScore|minScore|upside|value"``).
        """
        return self._parms.get("metric_regex")

    @metric_regex.setter
    def metric_regex(self, metric_regex):
        assert_is_type(metric_regex, None, str)
        self._parms["metric_regex"] = metric_regex


    @property
    def label_record_id(self):
        """
        label_record_id configuration value. Defaults to "recordId".

        Type: ``str``  (default: ``"recordId"``).
        """
        return self._parms.get("label_record_id")

    @label_record_id.setter
    def label_record_id(self, label_record_id):
        assert_is_type(label_record_id, None, str)
        self._parms["label_record_id"] = label_record_id


    @property
    def label_run(self):
        """
        label_run configuration value. Defaults to "run".

        Type: ``str``  (default: ``"run"``).
        """
        return self._parms.get("label_run")

    @label_run.setter
    def label_run(self, label_run):
        assert_is_type(label_run, None, str)
        self._parms["label_run"] = label_run


    @property
    def label_passthrough(self):
        """
        label_passthrough configuration value. Defaults to "__passthrough__".

        Type: ``str``  (default: ``"__passthrough__"``).
        """
        return self._parms.get("label_passthrough")

    @label_passthrough.setter
    def label_passthrough(self, label_passthrough):
        assert_is_type(label_passthrough, None, str)
        self._parms["label_passthrough"] = label_passthrough


    @property
    def label_sampled_score(self):
        """
        label_sampled_score configuration value. Defaults to "__sampledScore__".

        Type: ``str``  (default: ``"__sampledScore__"``).
        """
        return self._parms.get("label_sampled_score")

    @label_sampled_score.setter
    def label_sampled_score(self, label_sampled_score):
        assert_is_type(label_sampled_score, None, str)
        self._parms["label_sampled_score"] = label_sampled_score


    @property
    def label_score(self):
        """
        label_score configuration value. Defaults to "actualScore".

        Type: ``str``  (default: ``"actualScore"``).
        """
        return self._parms.get("label_score")

    @label_score.setter
    def label_score(self, label_score):
        assert_is_type(label_score, None, str)
        self._parms["label_score"] = label_score


    @property
    def label_bin(self):
        """
        label_bin configuration value. Defaults to "bin".

        Type: ``str``  (default: ``"bin"``).
        """
        return self._parms.get("label_bin")

    @label_bin.setter
    def label_bin(self, label_bin):
        assert_is_type(label_bin, None, str)
        self._parms["label_bin"] = label_bin


    @property
    def label_bin_prob(self):
        """
        label_bin_prob configuration value. Defaults to "binProb".

        Type: ``str``  (default: ``"binProb"``).
        """
        return self._parms.get("label_bin_prob")

    @label_bin_prob.setter
    def label_bin_prob(self, label_bin_prob):
        assert_is_type(label_bin_prob, None, str)
        self._parms["label_bin_prob"] = label_bin_prob


    @property
    def label_variable(self):
        """
        label_variable configuration value. Defaults to "variable".

        Type: ``str``  (default: ``"variable"``).
        """
        return self._parms.get("label_variable")

    @label_variable.setter
    def label_variable(self, label_variable):
        assert_is_type(label_variable, None, str)
        self._parms["label_variable"] = label_variable


    @property
    def label_value(self):
        """
        label_value configuration value. Defaults to "value".

        Type: ``str``  (default: ``"value"``).
        """
        return self._parms.get("label_value")

    @label_value.setter
    def label_value(self, label_value):
        assert_is_type(label_value, None, str)
        self._parms["label_value"] = label_value


    @property
    def label_min_score(self):
        """
        label_min_score configuration value. Defaults to "minScore".

        Type: ``str``  (default: ``"minScore"``).
        """
        return self._parms.get("label_min_score")

    @label_min_score.setter
    def label_min_score(self, label_min_score):
        assert_is_type(label_min_score, None, str)
        self._parms["label_min_score"] = label_min_score


    @property
    def label_max_score(self):
        """
        label_max_score configuration value. Defaults to "maxScore".

        Type: ``str``  (default: ``"maxScore"``).
        """
        return self._parms.get("label_max_score")

    @label_max_score.setter
    def label_max_score(self, label_max_score):
        assert_is_type(label_max_score, None, str)
        self._parms["label_max_score"] = label_max_score


    @property
    def label_range(self):
        """
        label_range configuration value. Defaults to "range".

        Type: ``str``  (default: ``"range"``).
        """
        return self._parms.get("label_range")

    @label_range.setter
    def label_range(self, label_range):
        assert_is_type(label_range, None, str)
        self._parms["label_range"] = label_range


    @property
    def label_upside(self):
        """
        label_upside configuration value. Defaults to "upside".

        Type: ``str``  (default: ``"upside"``).
        """
        return self._parms.get("label_upside")

    @label_upside.setter
    def label_upside(self, label_upside):
        assert_is_type(label_upside, None, str)
        self._parms["label_upside"] = label_upside


    @property
    def label_downside(self):
        """
        label_downside configuration value. Defaults to "downside".

        Type: ``str``  (default: ``"downside"``).
        """
        return self._parms.get("label_downside")

    @label_downside.setter
    def label_downside(self, label_downside):
        assert_is_type(label_downside, None, str)
        self._parms["label_downside"] = label_downside


    @property
    def label_expected_upside(self):
        """
        label_expected_upside configuration value. Defaults to "expectedUpside".

        Type: ``str``  (default: ``"expectedUpside"``).
        """
        return self._parms.get("label_expected_upside")

    @label_expected_upside.setter
    def label_expected_upside(self, label_expected_upside):
        assert_is_type(label_expected_upside, None, str)
        self._parms["label_expected_upside"] = label_expected_upside


    @property
    def label_expected_downside(self):
        """
        label_expected_downside configuration value. Defaults to "expectedDownside".

        Type: ``str``  (default: ``"expectedDownside"``).
        """
        return self._parms.get("label_expected_downside")

    @label_expected_downside.setter
    def label_expected_downside(self, label_expected_downside):
        assert_is_type(label_expected_downside, None, str)
        self._parms["label_expected_downside"] = label_expected_downside


    @property
    def label_upside_prob(self):
        """
        label_upside_prob configuration value. Defaults to "upsideProb".

        Type: ``str``  (default: ``"upsideProb"``).
        """
        return self._parms.get("label_upside_prob")

    @label_upside_prob.setter
    def label_upside_prob(self, label_upside_prob):
        assert_is_type(label_upside_prob, None, str)
        self._parms["label_upside_prob"] = label_upside_prob


    @property
    def label_downside_prob(self):
        """
        label_downside_prob configuration value. Defaults to "downsideProb".

        Type: ``str``  (default: ``"downsideProb"``).
        """
        return self._parms.get("label_downside_prob")

    @label_downside_prob.setter
    def label_downside_prob(self, label_downside_prob):
        assert_is_type(label_downside_prob, None, str)
        self._parms["label_downside_prob"] = label_downside_prob


    @property
    def label_normalized_upside(self):
        """
        label_normalized_upside configuration value. Defaults to "normalizedUpside".

        Type: ``str``  (default: ``"normalizedUpside"``).
        """
        return self._parms.get("label_normalized_upside")

    @label_normalized_upside.setter
    def label_normalized_upside(self, label_normalized_upside):
        assert_is_type(label_normalized_upside, None, str)
        self._parms["label_normalized_upside"] = label_normalized_upside


    @property
    def label_normalized_downside(self):
        """
        label_normalized_downside configuration value. Defaults to "normalizedDownside".

        Type: ``str``  (default: ``"normalizedDownside"``).
        """
        return self._parms.get("label_normalized_downside")

    @label_normalized_downside.setter
    def label_normalized_downside(self, label_normalized_downside):
        assert_is_type(label_normalized_downside, None, str)
        self._parms["label_normalized_downside"] = label_normalized_downside


    @property
    def label_rank(self):
        """
        label_rank configuration value. Defaults to "rank".

        Type: ``str``  (default: ``"rank"``).
        """
        return self._parms.get("label_rank")

    @label_rank.setter
    def label_rank(self, label_rank):
        assert_is_type(label_rank, None, str)
        self._parms["label_rank"] = label_rank


    @property
    def model_key(self):
        """
        key to h2o model on which the tea analysis is going to be scored

        Type: ``str``.
        """
        return self._parms.get("model_key")

    @model_key.setter
    def model_key(self, model_key):
        assert_is_type(model_key, None, str, H2OEstimator)
        self._parms["model_key"] = model_key


    @property
    def score_threshold(self):
        """
        score_threshold. Defaults to 1e-4.

        Type: ``float``  (default: ``0.0001``).
        """
        return self._parms.get("score_threshold")

    @score_threshold.setter
    def score_threshold(self, score_threshold):
        assert_is_type(score_threshold, None, numeric)
        self._parms["score_threshold"] = score_threshold


    @property
    def score_label(self):
        """
        score_label. Defaults to "actualScore"

        Type: ``str``  (default: ``"actualScore"``).
        """
        return self._parms.get("score_label")

    @score_label.setter
    def score_label(self, score_label):
        assert_is_type(score_label, None, str)
        self._parms["score_label"] = score_label


    @property
    def model_scoring_function_result_id(self):
        """
        which column of model's scoring function result to use as score. Defaults to 0.

        Type: ``int``  (default: ``0``).
        """
        return self._parms.get("model_scoring_function_result_id")

    @model_scoring_function_result_id.setter
    def model_scoring_function_result_id(self, model_scoring_function_result_id):
        assert_is_type(model_scoring_function_result_id, None, int)
        self._parms["model_scoring_function_result_id"] = model_scoring_function_result_id


    @property
    def record_id(self):
        """
        record_id

        Type: ``str``.
        """
        return self._parms.get("record_id")

    @record_id.setter
    def record_id(self, record_id):
        assert_is_type(record_id, None, str)
        self._parms["record_id"] = record_id


    @property
    def explain_field_regex(self):
        """
        variables in provided dataset that match the explain_field_regex and that are also in the precomputed bins will
        be explained. Defaults to ".*".

        Type: ``str``  (default: ``".*"``).
        """
        return self._parms.get("explain_field_regex")

    @explain_field_regex.setter
    def explain_field_regex(self, explain_field_regex):
        assert_is_type(explain_field_regex, None, str)
        self._parms["explain_field_regex"] = explain_field_regex


    @property
    def ranking_metric(self):
        """
        ranking_metric. Defaults to "upside".

        Type: ``str``  (default: ``"upside"``).
        """
        return self._parms.get("ranking_metric")

    @ranking_metric.setter
    def ranking_metric(self, ranking_metric):
        assert_is_type(ranking_metric, None, str)
        self._parms["ranking_metric"] = ranking_metric


    @property
    def special_values(self):
        """
        Grid search parameters.

        Type: ``Dict[object, object]``.
        """
        return self._parms.get("special_values")

    @special_values.setter
    def special_values(self, special_values):
        assert_is_type(special_values, None, {object: object})
        self._parms["special_values"] = special_values


    def variable_rank_count_plot(self, variable, png_path=None):
        data = self._get_variable_rank_count_plot_data(variable)
        if png_path != None:
            import matplotlib.pyplot as plt
            self._plot_variable_rank_count(data.as_data_frame().get_values(), png_path)
        return data


    def _get_variable_rank_count_plot_data(self, variable):
        import h2o
        j = h2o.api("POST /3/VariableRankCountPlot",
                    data={"overall_metrics": self._model_json["output"]['overall_metrics']['frame_id']['name'], "variable": variable})
        return h2o.get_frame(j['plot_output']['name'])



    def _get_variable_inclusion_plot_data(self):
        import h2o
        j = h2o.api("POST /3/VariableInclusionPlot",
                    data={"plot_input": self._model_json["output"]['overall_metrics']['frame_id']['name']})
        return h2o.get_frame(j['plot_output']['name'])

    def variable_inclusion_plot(self, png_path=None):
        data = self._get_variable_inclusion_plot_data()
        if png_path != None:
            import matplotlib.pyplot as plt
            plt.figure(figsize=(10, 10))
            data_as_df = data.as_data_frame().get_values()
            self._plot_variable_inclusion(data_as_df, variable_names=data.names)
            plt.savefig(png_path)
            plt.show()
        return data

    def _plot_variable_inclusion(self, data, variable_names):
        import numpy as np
        import matplotlib.pyplot as plt
        ny = len(data[0])
        ind = list(range(ny))

        axes = []
        cum_size = np.zeros(ny)
        data = np.array(data)
        labels = ['1','2','3']
        colors=['royalblue', 'cornflowerblue', 'lightsteelblue']

        for i, row_data in enumerate(data):
            if (i > 0):
                color = colors[i - 1] if colors is not None else None
                axes.append(plt.bar(ind, row_data, bottom=cum_size,
                                    label=labels[i - 1], color=color))
                cum_size += row_data

        plt.xticks(ind, variable_names, rotation=40, horizontalalignment='right')
        plt.ylabel("Number of Records")
        plt.xlabel("Variable")
        plt.title('Variable Inclusion')

        for axis in axes:
            for bar in axis:
                w, h = bar.get_width(), bar.get_height()
                plt.text(bar.get_x() + w/2, bar.get_y() + h/2,
                         axis._label, ha="center",
                         va="center")




    def record_level_variable_simulation_plot(self, record_id_value, variable, png_path=None):
        import h2o
        sampling_var_id = self._model_json['output']['sampling_variables'].index(variable)
        sampled_score_by_var = h2o.get_frame(self._model_json['output']['sampled_scored_data_keys'][sampling_var_id]['name'])
        data = self._get_record_level_variable_simulation_plot_data(sampled_score_by_var, record_id_value, variable)
        if png_path != None:
            import matplotlib.pyplot as plt
            self._plot_record_level_variable_simulation(data.as_data_frame().get_values(), png_path)
        return data

    def _plot_record_level_variable_simulation(self, data, png_path):
        import matplotlib
        matplotlib.use('Agg')
        import matplotlib.pyplot as plt

        x = data[:,2]
        y_sampled_score = data[:,4]
        y_actual_score = data[:,3]

        lists = sorted(zip(*[x, y_sampled_score]))
        new_x, new_y_sampled_score =  zip(*sorted(zip(x, y_sampled_score)))  #list(zip(*lists))
        plt.plot(x, y_actual_score, label = "Actual Score", color="grey")
        plt.plot(new_x, new_y_sampled_score, label = "Sampled Score")

        plt.xlabel("Variable Bins")
        plt.ylabel("Score")
        plt.legend(loc='upper right')
        plt.title("Record Level Variable Simulation for record:" + str(data[0,0]) + " and variable " + data[0,1])
        plt.savefig(png_path, bbox_inches='tight')
        plt.close('all')

    def _get_record_level_variable_simulation_plot_data(self, sampled_score_by_var, record_id_value, variable):
        import h2o
        j = h2o.api("POST /3/RecordLevelVariableSimulationPlot",
                    data={"sampled_score_by_var": sampled_score_by_var.key, "record_id_value": record_id_value, "variable": variable})
        return h2o.get_frame(j['plot_output']['name'])



    def _get_explanations_plot_data(self):
        # plotData = Tea.getDataForExplanationsPlot(plotInput, plotScoreData, "ID");
        import h2o
        j = h2o.api("POST /3/ExplanationsPlot",
                    data={"overall_metrics": self._model_json["output"]['overall_metrics']['frame_id']['name'], "scored_data": self._model_json['output']['scored_data']['frame_id']['name'], "record_id": self.actual_params['record_id']})
        return h2o.get_frame(j['plot_output']['name'])

    def explanations_plot(self, png_path=None):
        data = self._get_explanations_plot_data()
        if png_path != None:
            import matplotlib.pyplot as plt
            self._plot_explanations(data.as_data_frame().get_values(), png_path)
        return data


    def _plot_explanations(self, data, png_path):
        import matplotlib
        matplotlib.use('Agg')
        import numpy as np
        import matplotlib.pyplot as plt

        y_pos = np.arange(len(data[:,0]))
        bar_width = .55

        fig, axs = plt.subplots(1,2, figsize=(18,len(data[:,1])/5))
        fig.subplots_adjust(wspace=0, top=1, right=1, left=0, bottom=0)

        axs[1].barh(y_pos[::-1], data[:,3][::-1], bar_width,  align='center', alpha=0.4, color='royalblue', tick_label=data[:,3][::-1])
        axs[1].set_yticks([])
        axs[1].set_xlabel('Upside')
        axs[1].set_ylim(0 - .4, (len(data[:,1])) + .4)

        for i, v in enumerate( data[:,3]):
            axs[1].text(v, i, " " + str(v), va='center')

        cell_text = list(zip(data[:,0], data[:,2], data[:,1], data[:,4], data[:,5]))
        column_labels = ['RecordId', 'ActualScore',
                         "Variable", "Rank", "Value",
                         ]

        axs[0].axis('off')

        the_table = axs[0].table(cellText=cell_text,
                                 colLabels=column_labels,
                                 bbox=[0.4, 0.0, 0.6, 1.0])

        for i in range(len(data[:,1])):
            if the_table[i,0].get_text()._text == the_table[i + 1,0].get_text()._text and the_table[i,1].get_text()._text == the_table[i + 1,1].get_text()._text:
                the_table[i,0].visible_edges = 'RL'
                the_table[i,1].visible_edges = 'RL'
                the_table[i+1,0].visible_edges = 'RL'
                the_table[i+1,1].visible_edges = 'RL'
            if (i == len(data[:,1]) - 1):
                the_table[i+1,0].visible_edges = 'RLB'
                the_table[i+1,1].visible_edges = 'RLB'
            else:
                if(i != 0):
                    the_table[i,0].visible_edges = 'BRL'
                    the_table[i,1].visible_edges = 'BRL'

        plt.title("Explanations")

        plt.savefig(png_path, bbox_inches='tight')
        plt.show()
        plt.close('all')



    def _plot_variable_rank_count(self, data, png_path):
        import matplotlib
        matplotlib.use('Agg')
        import matplotlib.pyplot as plt


        fig, axs = plt.subplots(figsize=(15,len(data[:,1])))
        fig.subplots_adjust(wspace=0, top=1, right=1, left=0, bottom=0)

        formatter = "{:10.2f}"

        variable = [data[0,0], data[0,0], data[0,0], data[0,0], data[0,0]]
        bins = ["[0, " + formatter.format(data[0,31]) + "]",
                "(" + formatter.format(data[0,31]) + ", " + formatter.format(data[0,32]) + "]",
                "(" + formatter.format(data[0,32]) + ", " + formatter.format(data[0,33]) + "]",
                "(" + formatter.format(data[0,33]) + ", " + formatter.format(data[0,34]) + "]",
                "(" + formatter.format(data[0,34]) + " , 1]"]
        rank1bins = [data[0,1], data[0,2], data[0,3], data[0,4], data[0,5]]
        rank2bins = [data[0,6], data[0,7], data[0,8], data[0,9], data[0,10]]
        rank3bins = [data[0,11], data[0,12], data[0,13], data[0,14], data[0,15]]
        rank4bins = [data[0,16], data[0,17], data[0,18], data[0,19], data[0,20]]
        rank5bins = [data[0,21], data[0,22], data[0,23], data[0,24], data[0,25]]
        rank6bins = [data[0,26], data[0,27], data[0,28], data[0,29], data[0,30]]

        cell_text = list(zip(variable, bins, rank1bins, rank2bins, rank3bins, rank4bins, rank5bins, rank6bins))

        column_labels = ['Variable','Bin' ,'Rank 1', "Rank 2", "Rank 3", "Rank 4", "Rank 5", "Rank 6"]

        axs.axis('off')
        axs.table(cellText=cell_text, colLabels=column_labels)

        plt.title("Variable Rank Count Plot: " + data[0,0])
        plt.savefig(png_path, bbox_inches='tight')
        plt.show()
        plt.close('all')
