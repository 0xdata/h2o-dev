#!/usr/bin/env python
# -*- encoding: utf-8 -*-
#
# This file is auto-generated by h2o-3/h2o-bindings/bin/gen_python.py
# Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details)
#
from .estimator_base import H2OEstimator


class H2ODeepWaterEstimator(H2OEstimator):
    """
    Deep Water

    Build a supervised Deep Neural Network model for image classification
    Builds a artificial neural network on an H2OFrame containing paths of images

    Parameters
    ----------
      model_id : str
        Destination id for this model; auto-generated if not specified.

      checkpoint : str
        Model checkpoint to resume training with.

      training_frame : str
        Id of the training data frame (Not required, to allow initial validation of model parameters).

      validation_frame : str
        Id of the validation data frame.

      nfolds : int
        Number of folds for N-fold cross-validation (0 to disable or >= 2).
        Default: 0

      keep_cross_validation_predictions : bool
        Whether to keep the predictions of the cross-validation models.
        Default: False

      keep_cross_validation_fold_assignment : bool
        Whether to keep the cross-validation fold assignment.
        Default: False

      fold_assignment : "AUTO" | "Random" | "Modulo" | "Stratified"
        Cross-validation fold assignment scheme, if fold_column is not specified. The 'Stratified' option will stratify
        the folds based on the response variable, for classification problems.
        Default: "AUTO"

      fold_column : VecSpecifier
        Column with cross-validation fold index assignment per observation.

      response_column : VecSpecifier
        Response variable column.

      ignored_columns : list(str)
        Names of columns to ignore for training.

      score_each_iteration : bool
        Whether to score during each iteration of model training.
        Default: False

      overwrite_with_best_model : bool
        If enabled, override the final model with the best model found during training.
        Default: True

      epochs : float
        How many times the dataset should be iterated (streamed), can be fractional.
        Default: 10.0

      target_ratio_comm_to_comp : float
        Target ratio of communication overhead to computation. Only for multi-node operation and
        train_samples_per_iteration = -2 (auto-tuning).
        Default: 0.05

      seed : int
        Seed for random numbers (affects sampling) - Note: only reproducible when running single threaded.
        Default: -1

      rate : float
        Learning rate (higher => less stable, lower => slower convergence).
        Default: 0.005

      rate_annealing : float
        Learning rate annealing: rate / (1 + rate_annealing * samples).
        Default: 1e-06

      momentum_start : float
        Initial momentum at the beginning of training (try 0.5).
        Default: 0.9

      momentum_ramp : float
        Number of training samples for which momentum increases.
        Default: 10000.0

      momentum_stable : float
        Final momentum after the ramp is over (try 0.99).
        Default: 0.99

      distribution : "AUTO" | "bernoulli" | "multinomial" | "gaussian" | "poisson" | "gamma" | "tweedie" | "laplace" |
                     "quantile" | "huber"
        Distribution function
        Default: "AUTO"

      score_interval : float
        Shortest time interval (in seconds) between model scoring.
        Default: 5.0

      score_training_samples : int
        Number of training set samples for scoring (0 for all).
        Default: 10000

      score_validation_samples : int
        Number of validation set samples for scoring (0 for all).
        Default: 0

      score_duty_cycle : float
        Maximum duty cycle fraction for scoring (lower: more training, higher: more scoring).
        Default: 0.1

      stopping_rounds : int
        Early stopping based on convergence of stopping_metric. Stop if simple moving average of length k of the
        stopping_metric does not improve for k:=stopping_rounds scoring events (0 to disable)
        Default: 5

      stopping_metric : "AUTO" | "deviance" | "logloss" | "MSE" | "AUC" | "lift_top_group" | "r2" | "misclassification"
                        | "mean_per_class_error"
        Metric to use for early stopping (AUTO: logloss for classification, deviance for regression)
        Default: "AUTO"

      stopping_tolerance : float
        Relative tolerance for metric-based stopping criterion (stop if relative improvement is not at least this much)
        Default: 0.0

      max_runtime_secs : float
        Maximum allowed runtime in seconds for model training. Use 0 to disable.
        Default: 0.0

      replicate_training_data : bool
        Replicate the entire training dataset onto every node for faster training on small datasets.
        Default: True

      single_node_mode : bool
        Run on a single node for fine-tuning of model parameters.
        Default: False

      shuffle_training_data : bool
        Enable shuffling of training data (recommended if training data is replicated and train_samples_per_iteration is
        close to #nodes x #rows, of if using balance_classes).
        Default: True

      mini_batch_size : int
        Mini-batch size (smaller leads to better fit, larger can speed up and generalize better).
        Default: 32

      clip_gradient : float
        Clip gradients once their absolute value is larger than this value.
        Default: 10.0

      network : "auto" | "user" | "lenet" | "alexnet" | "vgg" | "vgg16" | "googlenet" | "inception_bn" | "resnet"
        Network architecture.
        Default: "auto"

      backend : "auto" | "mxnet" | "caffe" | "tensorflow"
        Deep Learning Backend.
        Default: "auto"

      width : int
        Width of image.
        Default: 0

      height : int
        Height of image.
        Default: 0

      channels : int
        Number of (color) channels.
        Default: 3

      device_id : int
        Device ID (which GPU).
        Default: 0

      network_definition_file : str
        Path of file containing network definition (graph, architecture).

      network_parameters_file : str
        Path of file containing network (initial) parameters (weights, biases).

      mean_image_file : str
        Path of file containing the mean image data for data normalization.

      export_native_model_prefix : str
        Path (prefix) where to export the native model after every iteration.

    """
    def __init__(self, **kwargs):
        super(H2ODeepWaterEstimator, self).__init__()
        self._parms = {}
        for name in ["model_id", "checkpoint", "training_frame", "validation_frame", "nfolds",
                     "keep_cross_validation_predictions", "keep_cross_validation_fold_assignment", "fold_assignment",
                     "fold_column", "response_column", "ignored_columns", "score_each_iteration",
                     "overwrite_with_best_model", "epochs", "target_ratio_comm_to_comp", "seed", "rate",
                     "rate_annealing", "momentum_start", "momentum_ramp", "momentum_stable", "distribution",
                     "score_interval", "score_training_samples", "score_validation_samples", "score_duty_cycle",
                     "stopping_rounds", "stopping_metric", "stopping_tolerance", "max_runtime_secs",
                     "replicate_training_data", "single_node_mode", "shuffle_training_data", "mini_batch_size",
                     "clip_gradient", "network", "backend", "width", "height", "channels", "device_id",
                     "network_definition_file", "network_parameters_file", "mean_image_file",
                     "export_native_model_prefix"]:
            pname = name[:-1] if name[-1] == '_' else name
            self._parms[pname] = kwargs[name] if name in kwargs else None

    @property
    def checkpoint(self):
        return self._parms["checkpoint"]

    @checkpoint.setter
    def checkpoint(self, value):
        self._parms["checkpoint"] = value

    @property
    def training_frame(self):
        return self._parms["training_frame"]

    @training_frame.setter
    def training_frame(self, value):
        self._parms["training_frame"] = value

    @property
    def validation_frame(self):
        return self._parms["validation_frame"]

    @validation_frame.setter
    def validation_frame(self, value):
        self._parms["validation_frame"] = value

    @property
    def nfolds(self):
        return self._parms["nfolds"]

    @nfolds.setter
    def nfolds(self, value):
        self._parms["nfolds"] = value

    @property
    def keep_cross_validation_predictions(self):
        return self._parms["keep_cross_validation_predictions"]

    @keep_cross_validation_predictions.setter
    def keep_cross_validation_predictions(self, value):
        self._parms["keep_cross_validation_predictions"] = value

    @property
    def keep_cross_validation_fold_assignment(self):
        return self._parms["keep_cross_validation_fold_assignment"]

    @keep_cross_validation_fold_assignment.setter
    def keep_cross_validation_fold_assignment(self, value):
        self._parms["keep_cross_validation_fold_assignment"] = value

    @property
    def fold_assignment(self):
        return self._parms["fold_assignment"]

    @fold_assignment.setter
    def fold_assignment(self, value):
        self._parms["fold_assignment"] = value

    @property
    def fold_column(self):
        return self._parms["fold_column"]

    @fold_column.setter
    def fold_column(self, value):
        self._parms["fold_column"] = value

    @property
    def response_column(self):
        return self._parms["response_column"]

    @response_column.setter
    def response_column(self, value):
        self._parms["response_column"] = value

    @property
    def ignored_columns(self):
        return self._parms["ignored_columns"]

    @ignored_columns.setter
    def ignored_columns(self, value):
        self._parms["ignored_columns"] = value

    @property
    def score_each_iteration(self):
        return self._parms["score_each_iteration"]

    @score_each_iteration.setter
    def score_each_iteration(self, value):
        self._parms["score_each_iteration"] = value

    @property
    def overwrite_with_best_model(self):
        return self._parms["overwrite_with_best_model"]

    @overwrite_with_best_model.setter
    def overwrite_with_best_model(self, value):
        self._parms["overwrite_with_best_model"] = value

    @property
    def epochs(self):
        return self._parms["epochs"]

    @epochs.setter
    def epochs(self, value):
        self._parms["epochs"] = value

    @property
    def target_ratio_comm_to_comp(self):
        return self._parms["target_ratio_comm_to_comp"]

    @target_ratio_comm_to_comp.setter
    def target_ratio_comm_to_comp(self, value):
        self._parms["target_ratio_comm_to_comp"] = value

    @property
    def seed(self):
        return self._parms["seed"]

    @seed.setter
    def seed(self, value):
        self._parms["seed"] = value

    @property
    def rate(self):
        return self._parms["rate"]

    @rate.setter
    def rate(self, value):
        self._parms["rate"] = value

    @property
    def rate_annealing(self):
        return self._parms["rate_annealing"]

    @rate_annealing.setter
    def rate_annealing(self, value):
        self._parms["rate_annealing"] = value

    @property
    def momentum_start(self):
        return self._parms["momentum_start"]

    @momentum_start.setter
    def momentum_start(self, value):
        self._parms["momentum_start"] = value

    @property
    def momentum_ramp(self):
        return self._parms["momentum_ramp"]

    @momentum_ramp.setter
    def momentum_ramp(self, value):
        self._parms["momentum_ramp"] = value

    @property
    def momentum_stable(self):
        return self._parms["momentum_stable"]

    @momentum_stable.setter
    def momentum_stable(self, value):
        self._parms["momentum_stable"] = value

    @property
    def distribution(self):
        return self._parms["distribution"]

    @distribution.setter
    def distribution(self, value):
        self._parms["distribution"] = value

    @property
    def score_interval(self):
        return self._parms["score_interval"]

    @score_interval.setter
    def score_interval(self, value):
        self._parms["score_interval"] = value

    @property
    def score_training_samples(self):
        return self._parms["score_training_samples"]

    @score_training_samples.setter
    def score_training_samples(self, value):
        self._parms["score_training_samples"] = value

    @property
    def score_validation_samples(self):
        return self._parms["score_validation_samples"]

    @score_validation_samples.setter
    def score_validation_samples(self, value):
        self._parms["score_validation_samples"] = value

    @property
    def score_duty_cycle(self):
        return self._parms["score_duty_cycle"]

    @score_duty_cycle.setter
    def score_duty_cycle(self, value):
        self._parms["score_duty_cycle"] = value

    @property
    def stopping_rounds(self):
        return self._parms["stopping_rounds"]

    @stopping_rounds.setter
    def stopping_rounds(self, value):
        self._parms["stopping_rounds"] = value

    @property
    def stopping_metric(self):
        return self._parms["stopping_metric"]

    @stopping_metric.setter
    def stopping_metric(self, value):
        self._parms["stopping_metric"] = value

    @property
    def stopping_tolerance(self):
        return self._parms["stopping_tolerance"]

    @stopping_tolerance.setter
    def stopping_tolerance(self, value):
        self._parms["stopping_tolerance"] = value

    @property
    def max_runtime_secs(self):
        return self._parms["max_runtime_secs"]

    @max_runtime_secs.setter
    def max_runtime_secs(self, value):
        self._parms["max_runtime_secs"] = value

    @property
    def replicate_training_data(self):
        return self._parms["replicate_training_data"]

    @replicate_training_data.setter
    def replicate_training_data(self, value):
        self._parms["replicate_training_data"] = value

    @property
    def single_node_mode(self):
        return self._parms["single_node_mode"]

    @single_node_mode.setter
    def single_node_mode(self, value):
        self._parms["single_node_mode"] = value

    @property
    def shuffle_training_data(self):
        return self._parms["shuffle_training_data"]

    @shuffle_training_data.setter
    def shuffle_training_data(self, value):
        self._parms["shuffle_training_data"] = value

    @property
    def mini_batch_size(self):
        return self._parms["mini_batch_size"]

    @mini_batch_size.setter
    def mini_batch_size(self, value):
        self._parms["mini_batch_size"] = value

    @property
    def clip_gradient(self):
        return self._parms["clip_gradient"]

    @clip_gradient.setter
    def clip_gradient(self, value):
        self._parms["clip_gradient"] = value

    @property
    def network(self):
        return self._parms["network"]

    @network.setter
    def network(self, value):
        self._parms["network"] = value

    @property
    def backend(self):
        return self._parms["backend"]

    @backend.setter
    def backend(self, value):
        self._parms["backend"] = value

    @property
    def width(self):
        return self._parms["width"]

    @width.setter
    def width(self, value):
        self._parms["width"] = value

    @property
    def height(self):
        return self._parms["height"]

    @height.setter
    def height(self, value):
        self._parms["height"] = value

    @property
    def channels(self):
        return self._parms["channels"]

    @channels.setter
    def channels(self, value):
        self._parms["channels"] = value

    @property
    def device_id(self):
        return self._parms["device_id"]

    @device_id.setter
    def device_id(self, value):
        self._parms["device_id"] = value

    @property
    def network_definition_file(self):
        return self._parms["network_definition_file"]

    @network_definition_file.setter
    def network_definition_file(self, value):
        self._parms["network_definition_file"] = value

    @property
    def network_parameters_file(self):
        return self._parms["network_parameters_file"]

    @network_parameters_file.setter
    def network_parameters_file(self, value):
        self._parms["network_parameters_file"] = value

    @property
    def mean_image_file(self):
        return self._parms["mean_image_file"]

    @mean_image_file.setter
    def mean_image_file(self, value):
        self._parms["mean_image_file"] = value

    @property
    def export_native_model_prefix(self):
        return self._parms["export_native_model_prefix"]

    @export_native_model_prefix.setter
    def export_native_model_prefix(self, value):
        self._parms["export_native_model_prefix"] = value

