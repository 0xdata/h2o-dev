#!/usr/bin/env python
# -*- encoding: utf-8 -*-
#
# This file is auto-generated by h2o-3/h2o-bindings/bin/gen_python.py
# Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details)
#
from __future__ import absolute_import, division, print_function, unicode_literals

import re
from h2o.estimators.estimator_base import H2OEstimator
from h2o.exceptions import H2OValueError
from h2o.utils.typechecks import assert_is_type, numeric


class H2OKMeansEstimator(H2OEstimator):
    """
    K-means

    Performs k-means clustering on an H2O dataset.
    """

    algo = "kmeans"

    def __init__(self, **kwargs):
        super(H2OKMeansEstimator, self).__init__()
        self._parms = {}
        names_list = {"model_id", "training_frame", "validation_frame", "nfolds", "keep_cross_validation_predictions",
                      "keep_cross_validation_fold_assignment", "fold_assignment", "fold_column", "ignored_columns",
                      "ignore_const_cols", "score_each_iteration", "k", "user_points", "max_iterations", "standardize",
                      "seed", "init", "max_runtime_secs"}
        if "Lambda" in kwargs: kwargs["lambda_"] = kwargs.pop("Lambda")
        for pname in kwargs:
            sname = pname[:-1] if pname[-1] == '_' else pname
            if pname in names_list:
                self._parms[sname] = kwargs[pname]
            else:
                raise H2OValueError("Unknown parameter %s" % pname)

    @property
    def training_frame(self):
        """str: Id of the training data frame (Not required, to allow initial validation of model parameters)."""
        return self._parms.get("training_frame")

    @training_frame.setter
    def training_frame(self, value):
        assert_is_type(value, str)
        self._parms["training_frame"] = value


    @property
    def validation_frame(self):
        """str: Id of the validation data frame."""
        return self._parms.get("validation_frame")

    @validation_frame.setter
    def validation_frame(self, value):
        assert_is_type(value, str)
        self._parms["validation_frame"] = value


    @property
    def nfolds(self):
        """int: Number of folds for N-fold cross-validation (0 to disable or >= 2). (Default: 0)"""
        return self._parms.get("nfolds")

    @nfolds.setter
    def nfolds(self, value):
        assert_is_type(value, int)
        self._parms["nfolds"] = value


    @property
    def keep_cross_validation_predictions(self):
        """bool: Whether to keep the predictions of the cross-validation models. (Default: False)"""
        return self._parms.get("keep_cross_validation_predictions")

    @keep_cross_validation_predictions.setter
    def keep_cross_validation_predictions(self, value):
        assert_is_type(value, bool)
        self._parms["keep_cross_validation_predictions"] = value


    @property
    def keep_cross_validation_fold_assignment(self):
        """bool: Whether to keep the cross-validation fold assignment. (Default: False)"""
        return self._parms.get("keep_cross_validation_fold_assignment")

    @keep_cross_validation_fold_assignment.setter
    def keep_cross_validation_fold_assignment(self, value):
        assert_is_type(value, bool)
        self._parms["keep_cross_validation_fold_assignment"] = value


    @property
    def fold_assignment(self):
        """
        Enum["auto", "random", "modulo", "stratified"]: Cross-validation fold assignment scheme, if fold_column is not
        specified. The 'Stratified' option will stratify the folds based on the response variable, for classification
        problems. (Default: "auto")
        """
        return self._parms.get("fold_assignment")

    @fold_assignment.setter
    def fold_assignment(self, value):
        simple_val = re.sub(r"[^a-z]+", "", value.lower())
        assert_is_type(simple_val, "auto", "random", "modulo", "stratified")
        self._parms["fold_assignment"] = value


    @property
    def fold_column(self):
        """str: Column with cross-validation fold index assignment per observation."""
        return self._parms.get("fold_column")

    @fold_column.setter
    def fold_column(self, value):
        assert_is_type(value, str)
        self._parms["fold_column"] = value


    @property
    def ignored_columns(self):
        """List[str]: Names of columns to ignore for training."""
        return self._parms.get("ignored_columns")

    @ignored_columns.setter
    def ignored_columns(self, value):
        assert_is_type(value, [str])
        self._parms["ignored_columns"] = value


    @property
    def ignore_const_cols(self):
        """bool: Ignore constant columns. (Default: True)"""
        return self._parms.get("ignore_const_cols")

    @ignore_const_cols.setter
    def ignore_const_cols(self, value):
        assert_is_type(value, bool)
        self._parms["ignore_const_cols"] = value


    @property
    def score_each_iteration(self):
        """bool: Whether to score during each iteration of model training. (Default: False)"""
        return self._parms.get("score_each_iteration")

    @score_each_iteration.setter
    def score_each_iteration(self, value):
        assert_is_type(value, bool)
        self._parms["score_each_iteration"] = value


    @property
    def k(self):
        """int: Number of clusters (Default: 1)"""
        return self._parms.get("k")

    @k.setter
    def k(self, value):
        assert_is_type(value, int)
        self._parms["k"] = value


    @property
    def user_points(self):
        """str: User-specified points"""
        return self._parms.get("user_points")

    @user_points.setter
    def user_points(self, value):
        assert_is_type(value, str)
        self._parms["user_points"] = value


    @property
    def max_iterations(self):
        """int: Maximum training iterations (Default: 1000)"""
        return self._parms.get("max_iterations")

    @max_iterations.setter
    def max_iterations(self, value):
        assert_is_type(value, int)
        self._parms["max_iterations"] = value


    @property
    def standardize(self):
        """bool: Standardize columns (Default: True)"""
        return self._parms.get("standardize")

    @standardize.setter
    def standardize(self, value):
        assert_is_type(value, bool)
        self._parms["standardize"] = value


    @property
    def seed(self):
        """int: RNG Seed (Default: -1)"""
        return self._parms.get("seed")

    @seed.setter
    def seed(self, value):
        assert_is_type(value, int)
        self._parms["seed"] = value


    @property
    def init(self):
        """Enum["random", "plus_plus", "furthest", "user"]: Initialization mode (Default: "furthest")"""
        return self._parms.get("init")

    @init.setter
    def init(self, value):
        simple_val = re.sub(r"[^a-z]+", "", value.lower())
        assert_is_type(simple_val, "random", "plusplus", "furthest", "user")
        self._parms["init"] = value


    @property
    def max_runtime_secs(self):
        """float: Maximum allowed runtime in seconds for model training. Use 0 to disable. (Default: 0.0)"""
        return self._parms.get("max_runtime_secs")

    @max_runtime_secs.setter
    def max_runtime_secs(self, value):
        assert_is_type(value, numeric)
        self._parms["max_runtime_secs"] = value


